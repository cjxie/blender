diff --git a/build_files/build_environment/BUILD_NOTES.txt b/build_files/build_environment/BUILD_NOTES.txt
new file mode 100644
index 00000000000..016bc719bdc
--- /dev/null
+++ b/build_files/build_environment/BUILD_NOTES.txt
@@ -0,0 +1,32 @@
+
+
+[1m[33mWARNING! (B[m[33m****WARNING****(B[m
+If you are experiencing issues building Blender, _*TRY A FRESH, CLEAN BUILD FIRST*_!
+The same goes for install_deps itself, if you encounter issues, please first erase everything in /root/src/blender-deps and /opt/lib
+(provided obviously you did not add anything yourself in those dirs!), and run install_deps.sh again!
+Often, changes in the libs built by this script, or in your distro package, cannot be handled simply, so...
+
+
+If you're using CMake add this to your configuration flags:
+  -D PYTHON_ROOT_DIR=/opt/lib/python-3.4
+  -D OPENCOLORIO_ROOT_DIR=/opt/lib/ocio
+  -D WITH_CYCLES_OSL=OFF
+  -D WITH_LLVM=OFF
+  -D WITH_CODEC_FFMPEG=ON
+  -D FFMPEG_LIBRARIES='avformat;avcodec;avutil;avdevice;swscale;rt;theora;theoradec;theoraenc;vorbis;vorbisenc;vorbisfile;ogg;x264;openjp2'
+  -D FFMPEG=/opt/lib/ffmpeg
+
+Or even simpler, just run (in your blender-source dir):
+  make -j12 BUILD_CMAKE_ARGS=" -D PYTHON_ROOT_DIR=/opt/lib/python-3.4 -D OPENCOLORIO_ROOT_DIR=/opt/lib/ocio -D WITH_CYCLES_OSL=OFF -D WITH_LLVM=OFF -D WITH_CODEC_FFMPEG=ON -D FFMPEG_LIBRARIES='avformat;avcodec;avutil;avdevice;swscale;rt;theora;theoradec;theoraenc;vorbis;vorbisenc;vorbisfile;ogg;x264;openjp2' -D FFMPEG=/opt/lib/ffmpeg"
+
+If you're using SCons add this to your user-config:
+BF_PYTHON = '/opt/lib/python-3.4'
+BF_PYTHON_ABI_FLAGS = 'm'
+WITH_BF_OCIO = True
+BF_OCIO = '/opt/lib/ocio'
+WITH_BF_OIIO = True
+WITH_BF_CYCLES = True
+WITH_BF_BOOST = True
+BF_FFMPEG = '/opt/lib/ffmpeg'
+BF_FFMPEG_LIB = 'avformat avcodec swscale avutil avdevice theora theoradec theoraenc vorbis vorbisenc vorbisfile ogg x264 openjp2'
+WITH_BF_3DMOUSE = False
diff --git a/build_files/build_environment/install_deps.sh b/build_files/build_environment/install_deps.sh
index 0d44ef96154..9cc05df240a 100755
--- a/build_files/build_environment/install_deps.sh
+++ b/build_files/build_environment/install_deps.sh
@@ -676,8 +676,8 @@ run_ldconfig() {
     WARNING "--no-sudo enabled, impossible to run ldconfig for $1, you'll have to do it yourself..."
   else
     INFO "Running ldconfig for $1..."
-    $SUDO sh -c "echo \"$_lib_path\" > $_ldconf_path"
-    $SUDO /sbin/ldconfig  # XXX OpenSuse does not include sbin in command path with sudo!!!
+    sh -c "echo \"$_lib_path\" > $_ldconf_path"
+    /sbin/ldconfig  # XXX OpenSuse does not include sbin in command path with sudo!!!
   fi
   PRINT ""
 }
@@ -832,7 +832,7 @@ compile_Boost() {
   if [ $? -eq 1 -o $BOOST_FORCE_REBUILD == true ]; then
     clean_Boost
   fi
-
+  INFO "$_inst"
   if [ ! -d $_inst ]; then
     INFO "Building Boost-$BOOST_VERSION"
 
@@ -912,10 +912,15 @@ compile_OCIO() {
       download OCIO_SOURCE[@] $_src.tar.gz
 
       INFO "Unpacking OpenColorIO-$OCIO_VERSION"
-      tar -C $SRC --transform "s,(.*/?)imageworks-OpenColorIO[^/]*(.*),\1OpenColorIO-$OCIO_VERSION\2,x" \
-          -xf $_src.tar.gz
-    fi
 
+      # --transform "s,(.*/?)OpenColorIO[^/]*(.*),\1OpenColorIO-$OCIO_VERSION\2,x" \
+
+      mkdir $_src
+      ls $SRC
+      tar -xzf $_src.tar.gz -C $_src --strip-components=1
+      
+    fi
+    
     cd $_src
     # Always refresh the whole build!
     if [ -d build ]; then
@@ -1621,16 +1626,33 @@ compile_FFmpeg() {
 
   # Clean install if needed!
   magic_compile_check ffmpeg-$FFMPEG_VERSION $ffmpeg_magic
-  if [ $? -eq 1 -o $FFMPEG_FORCE_REBUILD == true ]; then
-    clean_FFmpeg
-  fi
+  # if [ $? -eq 1 -o $FFMPEG_FORCE_REBUILD == true ]; then
+  #   clean_FFmpeg
+  # fi
 
   if [ ! -d $_inst ]; then
     INFO "Building ffmpeg-$FFMPEG_VERSION"
 
     prepare_opt
-
+    ls $SRC  
     if [ ! -d $_src ]; then
+      INFO "Downloading openjpeg"
+      
+      git clone https://github.com/uclouvain/openjpeg.git $SRC/openjpeg
+      cd $SRC/openjpeg
+      git checkout openjpeg-1.5
+      
+      if [ ! -d build ]; then
+        mkdir build
+      fi
+      
+      cmake -B build
+      $SUDO cmake --build build --target install -j$THREADS
+      cd -
+      INFO "Openjpeg is installed"
+
+
+
       INFO "Downloading ffmpeg-$FFMPEG_VERSION"
       mkdir -p $SRC
       download FFMPEG_SOURCE[@] "$_src.tar.bz2"
@@ -1758,7 +1780,7 @@ install_packages_DEB() {
   if [ ! $SUDO ]; then
     WARNING "--no-sudo enabled, impossible to run apt-get install for $@, you'll have to do it yourself..."
   else
-    $SUDO apt-get install -y --force-yes $@
+    apt-get install -y --force-yes $@
     if [ $? -ge 1 ]; then
       ERROR "apt-get failed to install requested packages, exiting."
       exit 1
@@ -1803,11 +1825,11 @@ install_DEB() {
   if [ ! $SUDO ]; then
     WARNING "--no-sudo enabled, impossible to run apt-get update, you'll have to do it yourself..."
   else
-    $SUDO apt-get update
+    apt-get update
   fi
 
   # These libs should always be available in debian/ubuntu official repository...
-  OPENJPEG_DEV="libopenjpeg-dev"
+  OPENJPEG_DEV="libopenjp2-7-dev"
   VORBIS_DEV="libvorbis-dev"
   OGG_DEV="libogg-dev"
   THEORA_DEV="libtheora-dev"
@@ -1815,7 +1837,7 @@ install_DEB() {
   _packages="gawk cmake cmake-curses-gui scons build-essential libjpeg-dev libpng-dev \
              libfreetype6-dev libx11-dev libxi-dev wget libsqlite3-dev libbz2-dev \
              libncurses5-dev libssl-dev liblzma-dev libreadline-dev $OPENJPEG_DEV \
-             libopenal-dev libglew-dev libglewmx-dev yasm $THEORA_DEV $VORBIS_DEV $OGG_DEV \
+             libopenal-dev libglew-dev yasm $THEORA_DEV $VORBIS_DEV $OGG_DEV \
              libsdl1.2-dev libfftw3-dev patch bzip2 libxml2-dev libtinyxml-dev"
 
   OPENJPEG_USE=true
diff --git a/intern/cycles/app/cycles_xml.cpp b/intern/cycles/app/cycles_xml.cpp
index eee64394471..a6c581b4427 100644
--- a/intern/cycles/app/cycles_xml.cpp
+++ b/intern/cycles/app/cycles_xml.cpp
@@ -354,6 +354,8 @@ static void xml_read_camera(const XMLReadState& state, pugi::xml_node node)
 		cam->panorama_type = PANORAMA_FISHEYE_EQUIDISTANT;
 	else if(xml_equal_string(node, "panorama_type", "fisheye_equisolid"))
 		cam->panorama_type = PANORAMA_FISHEYE_EQUISOLID;
+	else if(xml_equal_string(node, "panorama_type", "omni"))
+	  cam->panorama_type = PANORAMA_OMNI;
 
 	xml_read_float(&cam->fisheye_fov, node, "fisheye_fov");
 	xml_read_float(&cam->fisheye_lens, node, "fisheye_lens");
diff --git a/intern/cycles/blender/addon/properties.py b/intern/cycles/blender/addon/properties.py
index 16a807b3af5..dbff55e3d91 100644
--- a/intern/cycles/blender/addon/properties.py
+++ b/intern/cycles/blender/addon/properties.py
@@ -67,6 +67,7 @@ enum_panorama_types = (
     ('FISHEYE_EQUISOLID', "Fisheye Equisolid",
                           "Similar to most fisheye modern lens, takes sensor dimensions into consideration"),
     ('MIRRORBALL', "Mirror Ball", "Uses the mirror ball mapping"),
+    ('OMNI', "Omnidirectional", "Uses Scaramuzza omnidirectional camera model"),
     )
 
 enum_curve_primitives = (
@@ -617,6 +618,61 @@ class CyclesCameraSettings(bpy.types.PropertyGroup):
                 subtype='ANGLE',
                 default=math.pi,
                 )
+        cls.a0 = FloatProperty(
+                name="a0",
+                description="a0",
+                default=-2.108794e+02,
+                )
+        cls.a1 = FloatProperty(
+                name="a1",
+                description="a1",
+                default=0.0,
+                )
+        cls.a2 = FloatProperty(
+                name="a2",
+                description="a2",
+                default=1.971697e-03,
+                )
+        cls.a3 = FloatProperty(
+                name="a3",
+                description="a3",
+                default=-2.633567e-06,
+                )
+        cls.a4 = FloatProperty(
+                name="a4",
+                description="a4",
+                default=1.266556e-08,
+                )
+        cls.shift_cx = FloatProperty(
+                name="shift_cx",
+                description="shift_cx",
+                default=-21.763489,
+                )
+        cls.shift_cy = FloatProperty(
+                name="shift_cy",
+                description="shift_cy",
+                default=9.460006,
+                )
+        cls.c = FloatProperty(
+                name="c",
+                description="c",
+                default=0.999609,
+                )
+        cls.d = FloatProperty(
+                name="d",
+                description="d",
+                default=-0.000222,
+                )
+        cls.e = FloatProperty(
+                name="e",
+                description="e",
+                default=-0.000116,
+                )
+        cls.radius = FloatProperty(
+                name="radius",
+                description="radius",
+                default=0.0,
+                )
 
     @classmethod
     def unregister(cls):
diff --git a/intern/cycles/blender/blender_camera.cpp b/intern/cycles/blender/blender_camera.cpp
index 90b42ea4ec2..1d90343f1b3 100644
--- a/intern/cycles/blender/blender_camera.cpp
+++ b/intern/cycles/blender/blender_camera.cpp
@@ -57,6 +57,17 @@ struct BlenderCamera {
 	float latitude_max;
 	float longitude_min;
 	float longitude_max;
+  float a0;
+  float a1;
+  float a2;
+  float a3;
+  float a4;
+  float c;
+  float d;
+  float e;
+	float shift_cx;
+	float shift_cy;
+	float radius;
 
 	enum { AUTO, HORIZONTAL, VERTICAL } sensor_fit;
 	float sensor_width;
@@ -151,6 +162,9 @@ static void blender_camera_from_object(BlenderCamera *bcam, BL::RenderEngine b_e
 			case 3:
 				bcam->panorama_type = PANORAMA_MIRRORBALL;
 				break;
+      case 4:
+        bcam->panorama_type = PANORAMA_OMNI;
+        break;
 			case 0:
 			default:
 				bcam->panorama_type = PANORAMA_EQUIRECTANGULAR;
@@ -163,6 +177,17 @@ static void blender_camera_from_object(BlenderCamera *bcam, BL::RenderEngine b_e
 		bcam->latitude_max = RNA_float_get(&ccamera, "latitude_max");
 		bcam->longitude_min = RNA_float_get(&ccamera, "longitude_min");
 		bcam->longitude_max = RNA_float_get(&ccamera, "longitude_max");
+    bcam->a0 = RNA_float_get(&ccamera, "a0");
+    bcam->a1 = RNA_float_get(&ccamera, "a1");
+    bcam->a2 = RNA_float_get(&ccamera, "a2");
+    bcam->a3 = RNA_float_get(&ccamera, "a3");
+    bcam->a4 = RNA_float_get(&ccamera, "a4");
+    bcam->c = RNA_float_get(&ccamera, "c");
+    bcam->d = RNA_float_get(&ccamera, "d");
+    bcam->e = RNA_float_get(&ccamera, "e");
+		bcam->shift_cx = RNA_float_get(&ccamera, "shift_cx");
+		bcam->shift_cy = RNA_float_get(&ccamera, "shift_cy");
+		bcam->radius = RNA_float_get(&ccamera, "radius");
 
 		bcam->ortho_scale = b_camera.ortho_scale();
 
@@ -369,6 +394,18 @@ static void blender_camera_sync(Camera *cam, BlenderCamera *bcam, int width, int
 	cam->longitude_min = bcam->longitude_min;
 	cam->longitude_max = bcam->longitude_max;
 
+  cam->a0 = bcam->a0;
+  cam->a1 = bcam->a1;
+  cam->a2 = bcam->a2;
+  cam->a3 = bcam->a3;
+  cam->a4 = bcam->a4;
+  cam->c = bcam->c;
+  cam->d = bcam->d;
+  cam->e = bcam->e;
+	cam->shift_cx = bcam->shift_cx;
+	cam->shift_cy = bcam->shift_cy;
+	cam->radius = bcam->radius;
+
 	/* anamorphic lens bokeh */
 	cam->aperture_ratio = bcam->aperture_ratio;
 
diff --git a/intern/cycles/kernel/kernel_projection.h b/intern/cycles/kernel/kernel_projection.h
index 62922df3286..c7fc63a9ae9 100644
--- a/intern/cycles/kernel/kernel_projection.h
+++ b/intern/cycles/kernel/kernel_projection.h
@@ -5,7 +5,7 @@
  * All Rights Reserved.
  *
  * Modifications Copyright 2011, Blender Foundation.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are
  * met:
@@ -148,12 +148,66 @@ ccl_device float3 fisheye_equisolid_to_direction(float u, float v, float lens, f
 	if(v < 0.0f) phi = -phi;
 
 	return make_float3(
-		 cosf(theta),
-		 -cosf(phi)*sinf(theta),
+ 		 cosf(theta),
+ 		 -cosf(phi)*sinf(theta),
 		 sinf(phi)*sinf(theta)
 	);
 }
 
+/* Omnidirectional Model <-> Cartesian direction */
+
+ccl_device float3 omni_to_direction(float u,
+	float v,
+	float imageWidth,
+	float imageHeight,
+	float radiusPixels,
+	float a0,
+	float a1,
+	float a2,
+	float a3,
+	float a4,
+	float kC,
+	float kD,
+	float kE,
+	float cx,
+	float cy,
+	float invDetAffine) {
+	// scale coordinates and shift center
+	u = u * imageWidth - cx;
+	v = imageHeight * (1.f - v) - cy;
+
+	if(radiusPixels > 0.f && u*u + v*v > radiusPixels*radiusPixels)
+		return make_float3(0.f, 0.f, 0.f);
+
+	// inverse affine transformation
+	const float affine_u = invDetAffine * (kC * u - kE * v);
+	const float affine_v = invDetAffine * (-kD * u + v);
+
+	// ray z-direction
+	const float rho2 = affine_u * affine_u + affine_v * affine_v;
+	const float rho = sqrtf(rho2);
+	const float z = a0 + a1*rho + a2*rho2 + a3*rho2*rho + a4*rho2*rho2;
+	const float invnorm = 1.f / sqrtf(affine_u*affine_u + affine_v*affine_v + z*z);
+
+	return make_float3(
+		 - invnorm * z,
+		 - invnorm * affine_u,
+		 - invnorm * affine_v);
+}
+
+ccl_device float2 direction_to_omni(float3 dir,
+	float imageWidth,
+	float imageHeight,
+	float kC,
+	float kD,
+	float kE,
+	float cx,
+	float cy)
+{
+	// Not implemented yet.
+	return make_float2(0.0f, 0.0f);
+}
+
 /* Mirror Ball <-> Cartesion direction */
 
 ccl_device float3 mirrorball_to_direction(float u, float v)
@@ -193,32 +247,58 @@ ccl_device float2 direction_to_mirrorball(float3 dir)
 ccl_device float3 panorama_to_direction(KernelGlobals *kg, float u, float v)
 {
 	switch(kernel_data.cam.panorama_type) {
-		case PANORAMA_EQUIRECTANGULAR:
-			return equirectangular_range_to_direction(u, v, kernel_data.cam.equirectangular_range);
-		case PANORAMA_MIRRORBALL:
-			return mirrorball_to_direction(u, v);
-		case PANORAMA_FISHEYE_EQUIDISTANT:
-			return fisheye_to_direction(u, v, kernel_data.cam.fisheye_fov);
-		case PANORAMA_FISHEYE_EQUISOLID:
-		default:
-			return fisheye_equisolid_to_direction(u, v, kernel_data.cam.fisheye_lens,
-				kernel_data.cam.fisheye_fov, kernel_data.cam.sensorwidth, kernel_data.cam.sensorheight);
+	case PANORAMA_OMNI:
+		return omni_to_direction(u,
+														 v,
+														 kernel_data.cam.width,
+														 kernel_data.cam.height,
+														 kernel_data.cam.radius * kernel_data.cam.height / 2.f,
+														 kernel_data.cam.a0,
+														 kernel_data.cam.a1,
+														 kernel_data.cam.a2,
+														 kernel_data.cam.a3,
+														 kernel_data.cam.a4,
+														 kernel_data.cam.c,
+														 kernel_data.cam.d,
+														 kernel_data.cam.e,
+														 kernel_data.cam.width / 2.f + kernel_data.cam.shift_cx,
+														 kernel_data.cam.height / 2.f + kernel_data.cam.shift_cy,
+														 1.f / (kernel_data.cam.c - kernel_data.cam.d*kernel_data.cam.e));
+	case PANORAMA_EQUIRECTANGULAR:
+		return equirectangular_range_to_direction(u, v, kernel_data.cam.equirectangular_range);
+	case PANORAMA_MIRRORBALL:
+		return mirrorball_to_direction(u, v);
+	case PANORAMA_FISHEYE_EQUIDISTANT:
+		return fisheye_to_direction(u, v, kernel_data.cam.fisheye_fov);
+	case PANORAMA_FISHEYE_EQUISOLID:
+	default:
+		return fisheye_equisolid_to_direction(u, v, kernel_data.cam.fisheye_lens,
+																					kernel_data.cam.fisheye_fov, kernel_data.cam.sensorwidth, kernel_data.cam.sensorheight);
 	}
 }
 
 ccl_device float2 direction_to_panorama(KernelGlobals *kg, float3 dir)
 {
 	switch(kernel_data.cam.panorama_type) {
-		case PANORAMA_EQUIRECTANGULAR:
-			return direction_to_equirectangular_range(dir, kernel_data.cam.equirectangular_range);
-		case PANORAMA_MIRRORBALL:
-			return direction_to_mirrorball(dir);
-		case PANORAMA_FISHEYE_EQUIDISTANT:
-			return direction_to_fisheye(dir, kernel_data.cam.fisheye_fov);
-		case PANORAMA_FISHEYE_EQUISOLID:
-		default:
-			return direction_to_fisheye_equisolid(dir, kernel_data.cam.fisheye_lens,
-				kernel_data.cam.sensorwidth, kernel_data.cam.sensorheight);
+	case PANORAMA_OMNI:
+		return direction_to_omni(dir,
+														 kernel_data.cam.width,
+														 kernel_data.cam.height,
+														 kernel_data.cam.c,
+														 kernel_data.cam.d,
+														 kernel_data.cam.e,
+														 kernel_data.cam.width / 2.f + kernel_data.cam.shift_cx,
+														 kernel_data.cam.height / 2.f + kernel_data.cam.shift_cy);
+	case PANORAMA_EQUIRECTANGULAR:
+		return direction_to_equirectangular_range(dir, kernel_data.cam.equirectangular_range);
+	case PANORAMA_MIRRORBALL:
+		return direction_to_mirrorball(dir);
+	case PANORAMA_FISHEYE_EQUIDISTANT:
+		return direction_to_fisheye(dir, kernel_data.cam.fisheye_fov);
+	case PANORAMA_FISHEYE_EQUISOLID:
+	default:
+		return direction_to_fisheye_equisolid(dir, kernel_data.cam.fisheye_lens,
+																					kernel_data.cam.sensorwidth, kernel_data.cam.sensorheight);
 	}
 }
 
diff --git a/intern/cycles/kernel/kernel_types.h b/intern/cycles/kernel/kernel_types.h
index 1ef07629a3e..df652655826 100644
--- a/intern/cycles/kernel/kernel_types.h
+++ b/intern/cycles/kernel/kernel_types.h
@@ -443,7 +443,8 @@ enum PanoramaType {
 	PANORAMA_EQUIRECTANGULAR,
 	PANORAMA_MIRRORBALL,
 	PANORAMA_FISHEYE_EQUIDISTANT,
-	PANORAMA_FISHEYE_EQUISOLID
+	PANORAMA_FISHEYE_EQUISOLID,
+	PANORAMA_OMNI
 };
 
 /* Differential */
@@ -748,6 +749,17 @@ typedef struct KernelCamera {
 	int panorama_type;
 	float fisheye_fov;
 	float fisheye_lens;
+  float a0;
+  float a1;
+  float a2;
+  float a3;
+  float a4;
+  float c;
+  float d;
+  float e;
+	float shift_cx;
+	float shift_cy;
+	float radius;
 	float4 equirectangular_range;
 
 	/* matrices */
diff --git a/intern/cycles/render/buffers.cpp b/intern/cycles/render/buffers.cpp
index 011c722c000..309012bd3f4 100644
--- a/intern/cycles/render/buffers.cpp
+++ b/intern/cycles/render/buffers.cpp
@@ -396,7 +396,7 @@ void DisplayBuffer::write(Device *device, const string& filename)
 	device->pixels_copy_from(rgba, 0, w, h);
 
 	/* write image */
-	ImageOutput *out = ImageOutput::create(filename);
+	std::unique_ptr<ImageOutput> out = ImageOutput::create(filename);
 	ImageSpec spec(w, h, 4, TypeDesc::UINT8);
 	int scanlinesize = w*4*sizeof(uchar);
 
@@ -411,7 +411,7 @@ void DisplayBuffer::write(Device *device, const string& filename)
 
 	out->close();
 
-	delete out;
+	// delete out;
 }
 
 device_memory& DisplayBuffer::rgba_data()
diff --git a/intern/cycles/render/camera.cpp b/intern/cycles/render/camera.cpp
index 89505221862..5b6284e9cb3 100644
--- a/intern/cycles/render/camera.cpp
+++ b/intern/cycles/render/camera.cpp
@@ -260,6 +260,17 @@ void Camera::device_update(Device *device, DeviceScene *dscene, Scene *scene)
 	kcam->panorama_type = panorama_type;
 	kcam->fisheye_fov = fisheye_fov;
 	kcam->fisheye_lens = fisheye_lens;
+  kcam->a0 = a0;
+  kcam->a1 = a1;
+  kcam->a2 = a2;
+  kcam->a3 = a3;
+  kcam->a4 = a4;
+  kcam->c = c;
+  kcam->d = d;
+  kcam->e = e;
+	kcam->shift_cx = shift_cx;
+	kcam->shift_cy = shift_cy;
+	kcam->radius = radius;
 	kcam->equirectangular_range = make_float4(longitude_min - longitude_max, -longitude_min,
 	                                          latitude_min -  latitude_max, -latitude_min + M_PI_2_F);
 
@@ -337,10 +348,21 @@ bool Camera::modified(const Camera& cam)
 		(panorama_type == cam.panorama_type) &&
 		(fisheye_fov == cam.fisheye_fov) &&
 		(fisheye_lens == cam.fisheye_lens) &&
+    (a0 == cam.a0) &&
+    (a1 == cam.a1) &&
+    (a2 == cam.a2) &&
+    (a3 == cam.a3) &&
+    (a4 == cam.a4) &&
+    (c == cam.c) &&
+    (d == cam.d) &&
+    (e == cam.e) &&
+		(shift_cx == cam.shift_cx) &&
+		(shift_cy == cam.shift_cy) &&
+		(radius == cam.radius) &&
 		(latitude_min == cam.latitude_min) &&
 		(latitude_max == cam.latitude_max) &&
 		(longitude_min == cam.longitude_min) &&
-		(longitude_max == cam.longitude_max));
+    (longitude_max == cam.longitude_max));
 }
 
 bool Camera::motion_modified(const Camera& cam)
diff --git a/intern/cycles/render/camera.h b/intern/cycles/render/camera.h
index 3efbe904e2f..aafd2071ba8 100644
--- a/intern/cycles/render/camera.h
+++ b/intern/cycles/render/camera.h
@@ -57,6 +57,17 @@ public:
 	float latitude_max;
 	float longitude_min;
 	float longitude_max;
+	float a0;
+	float a1;
+	float a2;
+	float a3;
+	float a4;
+	float c;
+	float d;
+	float e;
+	float shift_cx;
+	float shift_cy;
+	float radius;
 
 	/* anamorphic lens bokeh */
 	float aperture_ratio;
diff --git a/intern/cycles/render/image.cpp b/intern/cycles/render/image.cpp
index c62afcd7719..8dba65b2ecb 100644
--- a/intern/cycles/render/image.cpp
+++ b/intern/cycles/render/image.cpp
@@ -105,7 +105,9 @@ bool ImageManager::is_float_image(const string& filename, void *builtin_data, bo
 		return is_float;
 	}
 
-	ImageInput *in = ImageInput::create(filename);
+	// ImageInput 
+	
+	std::unique_ptr<ImageInput> in = ImageInput::create(filename);
 
 	if(in) {
 		ImageSpec spec;
@@ -145,7 +147,7 @@ bool ImageManager::is_float_image(const string& filename, void *builtin_data, bo
 			in->close();
 		}
 
-		delete in;
+		// delete in;
 	}
 
 	return is_float;
@@ -353,7 +355,7 @@ bool ImageManager::file_load_image(Image *img, device_vector<uchar4>& tex_img)
 	if(img->filename == "")
 		return false;
 
-	ImageInput *in = NULL;
+	std::unique_ptr<ImageInput> in = NULL;
 	int width, height, depth, components;
 
 	if(!img->builtin_data) {
@@ -370,7 +372,7 @@ bool ImageManager::file_load_image(Image *img, device_vector<uchar4>& tex_img)
 			config.attribute("oiio:UnassociatedAlpha", 1);
 
 		if(!in->open(img->filename, spec, config)) {
-			delete in;
+			// delete in;
 			return false;
 		}
 
@@ -392,7 +394,7 @@ bool ImageManager::file_load_image(Image *img, device_vector<uchar4>& tex_img)
 	if(!(components >= 1 && components <= 4)) {
 		if(in) {
 			in->close();
-			delete in;
+			// delete in;
 		}
 
 		return false;
@@ -419,7 +421,7 @@ bool ImageManager::file_load_image(Image *img, device_vector<uchar4>& tex_img)
 		cmyk = strcmp(in->format_name(), "jpeg") == 0 && components == 4;
 
 		in->close();
-		delete in;
+		// delete in;
 	}
 	else {
 		builtin_image_pixels_cb(img->filename, img->builtin_data, pixels);
@@ -477,7 +479,7 @@ bool ImageManager::file_load_float_image(Image *img, device_vector<float4>& tex_
 	if(img->filename == "")
 		return false;
 
-	ImageInput *in = NULL;
+	std::unique_ptr<ImageInput> in = NULL;
 	int width, height, depth, components;
 
 	if(!img->builtin_data) {
@@ -494,7 +496,7 @@ bool ImageManager::file_load_float_image(Image *img, device_vector<float4>& tex_
 			config.attribute("oiio:UnassociatedAlpha",1);
 
 		if(!in->open(img->filename, spec, config)) {
-			delete in;
+			// delete in;
 			return false;
 		}
 
@@ -516,7 +518,7 @@ bool ImageManager::file_load_float_image(Image *img, device_vector<float4>& tex_
 	if(components < 1 || width == 0 || height == 0) {
 		if(in) {
 			in->close();
-			delete in;
+			// delete in;
 		}
 		return false;
 	}
@@ -562,7 +564,7 @@ bool ImageManager::file_load_float_image(Image *img, device_vector<float4>& tex_
 		cmyk = strcmp(in->format_name(), "jpeg") == 0 && components == 4;
 
 		in->close();
-		delete in;
+		// delete in;
 	}
 	else {
 		builtin_image_float_pixels_cb(img->filename, img->builtin_data, pixels);
diff --git a/release/scripts/startup/bl_ui/properties_data_camera.py b/release/scripts/startup/bl_ui/properties_data_camera.py
index 92ec34e01b2..bcb1e352594 100644
--- a/release/scripts/startup/bl_ui/properties_data_camera.py
+++ b/release/scripts/startup/bl_ui/properties_data_camera.py
@@ -106,6 +106,27 @@ class DATA_PT_lens(CameraButtonsPanel, Panel):
                     row = layout.row()
                     row.prop(ccam, "fisheye_lens", text="Lens")
                     row.prop(ccam, "fisheye_fov")
+                elif ccam.panorama_type == 'OMNI':
+                    row = layout.row()
+                    sub = row.column(align=True)
+                    sub.label(text="Polynomial:")
+                    sub.prop(ccam, "a0")
+                    sub.prop(ccam, "a1")
+                    sub.prop(ccam, "a2")
+                    sub.prop(ccam, "a3")
+                    sub.prop(ccam, "a4")
+                    sub = row.column(align=True)
+                    sub.label(text="Shift (pixels):")
+                    sub.prop(ccam, "shift_cx", text="X")
+                    sub.prop(ccam, "shift_cy", text="Y")
+                    sub = row.column(align=True)
+                    sub.label(text="Affine parameters:")
+                    sub.prop(ccam, "c")
+                    sub.prop(ccam, "d")
+                    sub.prop(ccam, "e")
+                    sub = row.column(align=True)
+                    sub.label(text="Radius (scale factor of half-height):")
+                    sub.prop(ccam, "radius", text="Radius")
                 elif ccam.panorama_type == 'EQUIRECTANGULAR':
                     row = layout.row()
                     sub = row.column(align=True)
@@ -114,6 +135,11 @@ class DATA_PT_lens(CameraButtonsPanel, Panel):
                     sub = row.column(align=True)
                     sub.prop(ccam, "longitude_min")
                     sub.prop(ccam, "longitude_max")
+                if not ccam.panorama_type == 'OMNI':
+                    col = split.column(align=True)
+                    col.label(text="Shift:")
+                    col.prop(cam, "shift_x", text="X")
+                    col.prop(cam, "shift_y", text="Y")
             elif engine == 'BLENDER_RENDER':
                 row = col.row()
                 if cam.lens_unit == 'MILLIMETERS':
@@ -123,12 +149,6 @@ class DATA_PT_lens(CameraButtonsPanel, Panel):
                 row.prop(cam, "lens_unit", text="")
 
         split = layout.split()
-
-        col = split.column(align=True)
-        col.label(text="Shift:")
-        col.prop(cam, "shift_x", text="X")
-        col.prop(cam, "shift_y", text="Y")
-
         col = split.column(align=True)
         col.label(text="Clipping:")
         col.prop(cam, "clip_start", text="Start")
diff --git a/source/blender/imbuf/intern/dds/DirectDrawSurface.cpp b/source/blender/imbuf/intern/dds/DirectDrawSurface.cpp
index 6bf82776afe..da27d69bc75 100644
--- a/source/blender/imbuf/intern/dds/DirectDrawSurface.cpp
+++ b/source/blender/imbuf/intern/dds/DirectDrawSurface.cpp
@@ -63,6 +63,8 @@
 #include <stdlib.h>  // malloc
 #include <math.h>  // sqrt
 #include <sys/types.h>
+#include <algorithm>
+using namespace std;
 
 /*** declarations ***/
 
diff --git a/source/blender/imbuf/intern/oiio/openimageio_api.cpp b/source/blender/imbuf/intern/oiio/openimageio_api.cpp
index 7728183d3b6..f52ffe4a629 100644
--- a/source/blender/imbuf/intern/oiio/openimageio_api.cpp
+++ b/source/blender/imbuf/intern/oiio/openimageio_api.cpp
@@ -88,7 +88,7 @@ static void fill_all_channels(T *pixels, int width, int height, int components,
 
 }
 
-static ImBuf *imb_oiio_load_image(ImageInput *in, int width, int height, int components, int flags, bool is_alpha)
+static ImBuf *imb_oiio_load_image(ImageInput::unique_ptr const& in, int width, int height, int components, int flags, bool is_alpha)
 {
 	ImBuf *ibuf;
 	int scanlinesize = width * components * sizeof(uchar);
@@ -127,7 +127,7 @@ static ImBuf *imb_oiio_load_image(ImageInput *in, int width, int height, int com
 	return ibuf;
 }
 
-static ImBuf *imb_oiio_load_image_float(ImageInput *in, int width, int height, int components, int flags, bool is_alpha)
+static ImBuf *imb_oiio_load_image_float(ImageInput::unique_ptr const& in, int width, int height, int components, int flags, bool is_alpha)
 {
 	ImBuf *ibuf;
 	int scanlinesize = width * components * sizeof(float);
@@ -197,7 +197,7 @@ int imb_save_photoshop(struct ImBuf *ibuf, const char * /*name*/, int flags)
 
 struct ImBuf *imb_load_photoshop(const char *filename, int flags, char colorspace[IM_MAX_SPACE])
 {
-	ImageInput *in = NULL;
+	std::unique_ptr<ImageInput> in = NULL;
 	struct ImBuf *ibuf = NULL;
 	int width, height, components;
 	bool is_float, is_alpha;
@@ -213,7 +213,7 @@ struct ImBuf *imb_load_photoshop(const char *filename, int flags, char colorspac
 	in = ImageInput::create(filename);
 	if (!in) {
 		std::cerr << __func__ << ": ImageInput::create() failed:" << std::endl
-		          << OpenImageIO::geterror() << std::endl;
+		          << OIIO::geterror() << std::endl;
 		return NULL;
 	}
 
@@ -223,7 +223,7 @@ struct ImBuf *imb_load_photoshop(const char *filename, int flags, char colorspac
 	if (!in->open(filename, spec, config)) {
 		std::cerr << __func__ << ": ImageInput::open() failed:" << std::endl
 		          << in->geterror() << std::endl;
-		delete in;
+		// delete in;
 		return NULL;
 	}
 
@@ -249,7 +249,7 @@ struct ImBuf *imb_load_photoshop(const char *filename, int flags, char colorspac
 	if (!(components >= 1 && components <= 4)) {
 		if (in) {
 			in->close();
-			delete in;
+			// delete in;
 		}
 		return NULL;
 	}
@@ -261,7 +261,7 @@ struct ImBuf *imb_load_photoshop(const char *filename, int flags, char colorspac
 
 	if (in) {
 		in->close();
-		delete in;
+		// delete in;
 	}
 
 	if (!ibuf)
